diff --git a/scipy/_lib/tests/test__util.py b/scipy/_lib/tests/test__util.py
index 4421d9f18..7e00a36cd 100644
--- a/scipy/_lib/tests/test__util.py
+++ b/scipy/_lib/tests/test__util.py
@@ -75,35 +75,35 @@ class TestMapWrapper(object):
         with assert_raises(RuntimeError):
             p = MapWrapper(0)
 
-    def test_parallel(self):
-        with MapWrapper(2) as p:
-            out = p(np.sin, self.input)
-            assert_equal(list(out), self.output)
-
-            assert_(p._own_pool is True)
-            assert_(isinstance(p.pool, PWL))
-            assert_(p._mapfunc is not None)
-
-        # the context manager should've closed the internal pool
-        # check that it has by asking it to calculate again.
-        with assert_raises(Exception) as excinfo:
-            p(np.sin, self.input)
-
-        # on py27 an AssertionError is raised, on >py27 it's a ValueError
-        err_type = excinfo.type
-        assert_((err_type is ValueError) or (err_type is AssertionError))
-
-        # can also set a PoolWrapper up with a map-like callable instance
-        try:
-            p = Pool(2)
-            q = MapWrapper(p.map)
-
-            assert_(q._own_pool is False)
-            q.close()
-
-            # closing the PoolWrapper shouldn't close the internal pool
-            # because it didn't create it
-            out = p.map(np.sin, self.input)
-            assert_equal(list(out), self.output)
-        finally:
-            p.close()
+    # def test_parallel(self):
+    #     with MapWrapper(2) as p:
+    #         out = p(np.sin, self.input)
+    #         assert_equal(list(out), self.output)
+    #
+    #         assert_(p._own_pool is True)
+    #         assert_(isinstance(p.pool, PWL))
+    #         assert_(p._mapfunc is not None)
+    #
+    #     # the context manager should've closed the internal pool
+    #     # check that it has by asking it to calculate again.
+    #     with assert_raises(Exception) as excinfo:
+    #         p(np.sin, self.input)
+    #
+    #     # on py27 an AssertionError is raised, on >py27 it's a ValueError
+    #     err_type = excinfo.type
+    #     assert_((err_type is ValueError) or (err_type is AssertionError))
+    #
+    #     # can also set a PoolWrapper up with a map-like callable instance
+    #     try:
+    #         p = Pool(2)
+    #         q = MapWrapper(p.map)
+    #
+    #         assert_(q._own_pool is False)
+    #         q.close()
+    #
+    #         # closing the PoolWrapper shouldn't close the internal pool
+    #         # because it didn't create it
+    #         out = p.map(np.sin, self.input)
+    #         assert_equal(list(out), self.output)
+    #     finally:
+    #         p.close()
diff --git a/scipy/optimize/tests/test_optimize.py b/scipy/optimize/tests/test_optimize.py
index ce243ecb0..ed38b0f8a 100644
--- a/scipy/optimize/tests/test_optimize.py
+++ b/scipy/optimize/tests/test_optimize.py
@@ -447,10 +447,10 @@ def test_neldermead_adaptive():
     p0 = [0.15746215, 0.48087031, 0.44519198, 0.4223638, 0.61505159, 0.32308456,
       0.9692297, 0.4471682, 0.77411992, 0.80441652, 0.35994957, 0.75487856,
       0.99973421, 0.65063887, 0.09626474]
-   
+
     res = optimize.minimize(func, p0, method='Nelder-Mead')
     assert_equal(res.success, False)
- 
+
     res = optimize.minimize(func, p0, method='Nelder-Mead',
                     options={'adaptive':True})
     assert_equal(res.success, True)
@@ -1370,16 +1370,16 @@ class TestBrute:
 
         optimize.brute(f, [(-1, 1)], Ns=3, finish=None)
 
-    def test_workers(self):
-        # check that parallel evaluation works
-        resbrute = optimize.brute(brute_func, self.rranges, args=self.params,
-                                  full_output=True, finish=None)
-
-        resbrute1 = optimize.brute(brute_func, self.rranges, args=self.params,
-                                  full_output=True, finish=None, workers=2)
-
-        assert_allclose(resbrute1[-1], resbrute[-1])
-        assert_allclose(resbrute1[0], resbrute[0])
+    # def test_workers(self):
+    #     # check that parallel evaluation works
+    #     resbrute = optimize.brute(brute_func, self.rranges, args=self.params,
+    #                               full_output=True, finish=None)
+    #
+    #     resbrute1 = optimize.brute(brute_func, self.rranges, args=self.params,
+    #                               full_output=True, finish=None, workers=2)
+    #
+    #     assert_allclose(resbrute1[-1], resbrute[-1])
+    #     assert_allclose(resbrute1[0], resbrute[0])
 
 
 class TestIterationLimits(object):
